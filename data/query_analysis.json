[
    {
        "sql_id": "sql_slow_001",
        "explication_plan": "Le plan 'TABLE ACCESS FULL' indique que la base de données doit lire chaque bloc de données de la table SALES pour récupérer toutes les lignes. C'est le plan par défaut pour un `SELECT *` sur une table lorsque aucune clause WHERE n'est spécifiée pour filtrer les données ou qu'il n'y a pas d'index couvrant toutes les colonnes, ce qui est très coûteux sur de grandes tables.",
        "points_couteux": [
            "**I/O intensif**: Nécessite la lecture de l'intégralité de la table depuis le disque ou le cache, générant une forte charge sur les sous-systèmes d'I/O et le bus de données.",
            "**Consommation de ressources**: Utilisation élevée du CPU et de la mémoire (SGA/PGA) pour scanner, traiter et potentiellement transférer toutes les lignes, particulièrement si la table est volumineuse.",
            "**Latence élevée**: Pour une table volumineuse, cela entraîne un temps de réponse potentiellement très long, car toutes les données doivent être lues et traitées avant de pouvoir être retournées à l'application."
        ],
        "recommandations": [
            {
                "type": "SQL/Conception",
                "description": "Si l'intention n'est pas de récupérer *toutes* les lignes et *toutes* les colonnes de la table `SALES`, il est crucial de redéfinir la requête. Ajouter une clause `WHERE` pertinente pour filtrer les données et spécifier uniquement les colonnes nécessaires (éviter `SELECT *`). Cela réduira drastiquement le volume de données à traiter et permettra d'utiliser des index."
            },
            {
                "type": "Index",
                "description": "Si la requête est filtrée via une clause `WHERE` (suite à la recommandation précédente), analyser les colonnes utilisées pour le filtrage et/ou la jointure. Créer un index B-Tree sur les colonnes à forte sélectivité dans la clause `WHERE` (par exemple, un ID de transaction, une date de vente spécifique). Cela permettrait à l'optimiseur d'utiliser un `INDEX RANGE SCAN` ou `INDEX UNIQUE SCAN` pour accéder directement aux données pertinentes, évitant ainsi le `TABLE ACCESS FULL`."
            },
            {
                "type": "Statistiques",
                "description": "Assurez-vous que les statistiques de la table `SALES` sont à jour. Exécutez `DBMS_STATS.GATHER_TABLE_STATS('VOTRE_SCHEMA', 'SALES', cascade=>true)` pour fournir des informations précises au CBO. *'VOTRE_SCHEMA'* est une estimation car le schéma n'est pas spécifié. Des statistiques périmées peuvent le conduire à choisir un plan inefficace comme le `TABLE ACCESS FULL` même si un index approprié existe."
            },
            {
                "type": "Hint (Conditionnel)",
                "description": "Si le `TABLE ACCESS FULL` est délibéré et considéré comme le plan optimal pour le cas d'usage (par exemple, la table est petite, ou toutes les données sont absolument nécessaires pour un rapport global), vous pouvez utiliser le hint `/*+ FULL(SALES) */` pour stabiliser le plan et s'assurer que l'optimiseur ne tente pas d'alternatives moins efficaces. *Note: Ce hint ne réduit pas le coût inhérent au full scan lui-même, mais assure la cohérence du plan choisi.*"
            }
        ],
        "gain_estime": "Le gain estimé dépend fortement de la possibilité de modifier la requête. Si la requête peut être optimisée en ajoutant une clause `WHERE` qui utilise un index (par exemple, `WHERE id = 5` comme dans l'Exemple 1), le gain de performance peut être **supérieur à 90%**. Si le `TABLE ACCESS FULL` est inévitable pour l'objectif de la requête (`SELECT * FROM SALES` sur une très grande table pour des raisons légitimes), les gains d'optimisation par d'autres moyens seraient plus marginaux (<10%) et liés à l'infrastructure (optimisation I/O, cache)."
    },
    {
    "sql_id": "sql_slow_002",
    "explication_plan": "Le plan d'exécution montre un `INDEX RANGE SCAN` suivi d’un `TABLE ACCESS BY INDEX ROWID` sur la table ORDERS. Cela signifie que l'optimiseur utilise bien un index pour localiser les lignes, mais que la plage de valeurs parcourue est trop large, entraînant la lecture de nombreuses entrées d’index et un accès fréquent à la table.",
    "points_couteux": [
      "**Sélectivité faible de l’index** : L’index utilisé (par exemple sur `order_date`) couvre une plage trop large de valeurs, ce qui réduit son efficacité.",
      "**Accès répétés à la table** : Chaque entrée trouvée dans l’index nécessite un accès supplémentaire à la table via le ROWID, augmentant le coût I/O.",
      "**Charge CPU modérée** : Le traitement d’un grand nombre de lignes indexées génère une consommation CPU non négligeable, surtout en cas de concurrence élevée."
    ],
    "recommandations": [
      {
        "type": "SQL/Conception",
        "description": "Affiner la clause `WHERE` afin de réduire la plage de valeurs scannée par l’index. Par exemple, combiner une condition sur la date avec une autre colonne plus sélective (`status`, `customer_id`)."
      },
      {
        "type": "Index",
        "description": "Créer un index composite (B-Tree) sur plusieurs colonnes utilisées conjointement dans la clause `WHERE`, par exemple `(order_date, status)`. Cela permettrait de réduire le nombre de lignes retournées par l’index et d’améliorer la sélectivité."
      },
      {
        "type": "Index couvrant",
        "description": "Si la requête sélectionne peu de colonnes, envisager un index couvrant (incluant toutes les colonnes nécessaires dans l’index). Cela peut permettre un `INDEX ONLY SCAN` et éviter totalement l’accès à la table."
      },
      {
        "type": "Statistiques",
        "description": "Vérifier et mettre à jour les statistiques des index et de la table ORDERS avec `DBMS_STATS.GATHER_TABLE_STATS('VOTRE_SCHEMA', 'ORDERS', cascade=>true)` afin que le CBO estime correctement la cardinalité et le coût du plan."
      }
    ],
    "gain_estime": "Si un index composite ou couvrant est mis en place et que la sélectivité est améliorée, le gain de performance peut atteindre **60 à 80%**. Sans modification de l’index, l’amélioration restera limitée (**10 à 20%**) et dépendra principalement de la réduction du volume de données retournées."
  }
]