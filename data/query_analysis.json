[
    {
        "sql_id": "sql_slow_001",
        "explication_plan": "Le plan 'TABLE ACCESS FULL' indique que la base de données doit lire chaque bloc de données de la table SALES pour récupérer toutes les lignes. C'est le plan par défaut pour un `SELECT *` sur une table lorsque aucune clause WHERE n'est spécifiée pour filtrer les données ou qu'il n'y a pas d'index couvrant toutes les colonnes, ce qui est très coûteux sur de grandes tables.",
        "points_couteux": [
            "**I/O intensif**: Nécessite la lecture de l'intégralité de la table depuis le disque ou le cache, générant une forte charge sur les sous-systèmes d'I/O et le bus de données.",
            "**Consommation de ressources**: Utilisation élevée du CPU et de la mémoire (SGA/PGA) pour scanner, traiter et potentiellement transférer toutes les lignes, particulièrement si la table est volumineuse.",
            "**Latence élevée**: Pour une table volumineuse, cela entraîne un temps de réponse potentiellement très long, car toutes les données doivent être lues et traitées avant de pouvoir être retournées à l'application."
        ],
        "recommandations": [
            {
                "type": "SQL/Conception",
                "description": "Si l'intention n'est pas de récupérer *toutes* les lignes et *toutes* les colonnes de la table `SALES`, il est crucial de redéfinir la requête. Ajouter une clause `WHERE` pertinente pour filtrer les données et spécifier uniquement les colonnes nécessaires (éviter `SELECT *`). Cela réduira drastiquement le volume de données à traiter et permettra d'utiliser des index."
            },
            {
                "type": "Index",
                "description": "Si la requête est filtrée via une clause `WHERE` (suite à la recommandation précédente), analyser les colonnes utilisées pour le filtrage et/ou la jointure. Créer un index B-Tree sur les colonnes à forte sélectivité dans la clause `WHERE` (par exemple, un ID de transaction, une date de vente spécifique). Cela permettrait à l'optimiseur d'utiliser un `INDEX RANGE SCAN` ou `INDEX UNIQUE SCAN` pour accéder directement aux données pertinentes, évitant ainsi le `TABLE ACCESS FULL`."
            },
            {
                "type": "Statistiques",
                "description": "Assurez-vous que les statistiques de la table `SALES` sont à jour. Exécutez `DBMS_STATS.GATHER_TABLE_STATS('VOTRE_SCHEMA', 'SALES', cascade=>true)` pour fournir des informations précises au CBO. *'VOTRE_SCHEMA'* est une estimation car le schéma n'est pas spécifié. Des statistiques périmées peuvent le conduire à choisir un plan inefficace comme le `TABLE ACCESS FULL` même si un index approprié existe."
            },
            {
                "type": "Hint (Conditionnel)",
                "description": "Si le `TABLE ACCESS FULL` est délibéré et considéré comme le plan optimal pour le cas d'usage (par exemple, la table est petite, ou toutes les données sont absolument nécessaires pour un rapport global), vous pouvez utiliser le hint `/*+ FULL(SALES) */` pour stabiliser le plan et s'assurer que l'optimiseur ne tente pas d'alternatives moins efficaces. *Note: Ce hint ne réduit pas le coût inhérent au full scan lui-même, mais assure la cohérence du plan choisi.*"
            }
        ],
        "gain_estime": "Le gain estimé dépend fortement de la possibilité de modifier la requête. Si la requête peut être optimisée en ajoutant une clause `WHERE` qui utilise un index (par exemple, `WHERE id = 5` comme dans l'Exemple 1), le gain de performance peut être **supérieur à 90%**. Si le `TABLE ACCESS FULL` est inévitable pour l'objectif de la requête (`SELECT * FROM SALES` sur une très grande table pour des raisons légitimes), les gains d'optimisation par d'autres moyens seraient plus marginaux (<10%) et liés à l'infrastructure (optimisation I/O, cache)."
    }
]