[
    {
        "sql_id": "sql_slow_001",
        "explication_plan": "Le plan d'exécution 'TABLE ACCESS FULL' indique que l'optimiseur Oracle effectue un parcours séquentiel complet de la table SALES. Cela signifie qu'il lit toutes les lignes de la table, ce qui est coûteux en termes d'I/O et de CPU, surtout si la table est volumineuse.",
        "points_couteux": [
            "Scan complet de la table (lecture de toutes les lignes)",
            "Absence d'utilisation d'index pour filtrer les données",
            "Consommation élevée d'I/O et de mémoire tampon"
        ],
        "recommandations": [
            {
                "type": "Index",
                "description": "Créer un index B-Tree sur la colonne de filtrage (ex: sales_id, customer_id) si la requête contient une clause WHERE avec une forte sélectivité. Ex: CREATE INDEX idx_sales_id ON sales(sales_id);"
            },
            {
                "type": "SQL",
                "description": "Remplacer 'SELECT *' par une liste explicite de colonnes nécessaires pour réduire la charge I/O et permettre une couverture d'index."
            },
            {
                "type": "Hint",
                "description": "Si un index existe mais n'est pas utilisé, forcer son utilisation avec /*+ INDEX(sales idx_sales_id) */ avant la clause SELECT."
            }
        ],
        "gain_estime": "70-95% (selon la taille de la table et la sélectivité du filtre)"
    },
    {
        "sql_id": "sql_fast_002",
        "explication_plan": "L'optimiseur Oracle utilise un INDEX UNIQUE SCAN, ce qui signifie qu'il parcourt un index unique (comme une clé primaire) pour retrouver une seule ligne correspondant exactement à la condition de la requête. C'est l'opération d'accès aux données la plus rapide pour une recherche par égalité sur une colonne indexée de manière unique.",
        "points_couteux": [
            "Aucun point coûteux identifié. L'INDEX UNIQUE SCAN est la méthode d'accès optimale pour ce type de requête de recherche par égalité sur un prédicat unique.",
            "Le plan fourni ne montre pas d'opérations de jointure, de tri (SORT) ou d'agrégation coûteuses qui pourraient être problématiques.",
            "Sans le plan d'exécution complet (COST, cardinalité, autres opérations), il est impossible d'identifier d'autres points de contention potentiels comme des conversions de type implicites ou des prédicats de filtre appliqués trop tard."
        ],
        "recommandations": [
            {
                "type": "SQL",
                "description": "Vérifier que la colonne utilisée dans la clause WHERE (non visible dans l'extrait SQL fourni) est bien la colonne sur laquelle porte l'index unique. Éviter d'appliquer des fonctions (comme UPPER, TO_CHAR) ou des opérations arithmétiques sur cette colonne dans la clause WHERE, car cela empêcherait l'utilisation de l'index."
            },
            {
                "type": "Index",
                "description": "S'assurer que l'index unique concerné est bien un index B-Tree standard. Si la requête sélectionne uniquement des colonnes présentes dans l'index (comme c'est le cas ici avec 'name' si 'name' fait partie de l'index), l'opération sera un 'INDEX FAST FULL SCAN' encore plus efficace pour des lectures multiples, mais l'INDEX UNIQUE SCAN reste parfait pour une recherche ponctuelle."
            },
            {
                "type": "Hint",
                "description": "Aucun hint n'est nécessaire ni recommandé. L'optimiseur a déjà choisi le plan optimal (INDEX UNIQUE SCAN). Forcer un autre accès avec un hint (comme /*+ FULL(EMP) */) dégraderait fortement les performances."
            }
        ],
        "gain_estime": "0% (Le plan actuel est déjà optimal pour une recherche par clé unique. Les optimisations proposées visent à maintenir cette performance et à éviter une dégradation accidentelle.)"
    },
    {
        "sql_id": "sql_complex_003",
        "explication_plan": "Le plan d'exécution utilise NESTED LOOPS pour joindre les tables ORDERS et CUSTOMERS. Cette méthode lit une ligne de la table externe (driving table) puis recherche les correspondances dans la table interne via un index. Elle est efficace lorsque la table externe est petite ou très filtrée, mais peut devenir très coûteuse si les deux tables sont grandes ou si l'index de la table interne est inefficace.",
        "points_couteux": [
            "Utilisation de NESTED LOOPS pour joindre potentiellement de grandes tables",
            "Absence d'information sur les filtres WHERE (risque de cartésien)",
            "Manque de détails sur les opérations d'accès aux tables (TABLE ACCESS FULL vs INDEX SCAN)"
        ],
        "recommandations": [
            {
                "type": "SQL",
                "description": "Ajouter des conditions WHERE explicites pour réduire le jeu de données avant la jointure. Ex: WHERE o.order_date > SYSDATE - 30 AND c.status = 'ACTIVE'"
            },
            {
                "type": "Index",
                "description": "Créer un index composite sur les colonnes de jointure et de filtrage. Ex: CREATE INDEX idx_orders_cust_date ON orders(customer_id, order_date)"
            },
            {
                "type": "Hint",
                "description": "Tester avec un hint HASH JOIN si les statistiques indiquent de grandes tables: /*+ LEADING(o) USE_HASH(c) */"
            }
        ],
        "gain_estime": "60-80% si NESTED LOOPS est inapproprié et remplacé par HASH JOIN avec filtres appropriés"
    },
    {
        "sql_id": "sql_sort_004",
        "explication_plan": "L'optimiseur effectue un scan complet de la table ITEMS (TABLE ACCESS FULL) pour récupérer toutes les lignes, puis trie l'ensemble du résultat en mémoire ou sur disque via l'opération SORT ORDER BY. Ce plan est coûteux car il nécessite de lire toute la table et de trier toutes les lignes.",
        "points_couteux": [
            "TABLE ACCESS FULL sur ITEMS (lecture de toutes les lignes)",
            "SORT ORDER BY (tri de l'ensemble du résultat en mémoire/disque)",
            "Absence d'index pour éviter le tri ou optimiser l'accès"
        ],
        "recommandations": [
            {
                "type": "Index",
                "description": "Créer un index sur la colonne price : CREATE INDEX idx_items_price ON items(price). Cela permettra à l'optimiseur d'utiliser un INDEX FULL SCAN (ordonné) pour éviter l'opération de tri explicite."
            },
            {
                "type": "Hint",
                "description": "Si l'index existe mais n'est pas utilisé, forcer son utilisation avec : SELECT /*+ INDEX(items idx_items_price) */ * FROM items ORDER BY price"
            },
            {
                "type": "SQL",
                "description": "Si seules quelques lignes sont nécessaires, limiter le résultat avec ROWNUM ou FETCH FIRST : SELECT * FROM items ORDER BY price FETCH FIRST 100 ROWS ONLY. Cela réduira considérablement la charge du tri."
            }
        ],
        "gain_estime": "70-90% si un index approprié est créé et utilisé (évite le tri et peut réduire les I/O via un scan d'index au lieu d'un scan de table)."
    }
]